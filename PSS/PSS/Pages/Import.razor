@page "/"
@using Microsoft.VisualBasic.FileIO

<title>Import - PSS</title>
<link href="css/Import.css" rel="stylesheet">

@{
	if (!finishedRendering)
		return;
	
	if (allAbsPaths is null || allAbsPaths.Count is 0)
	{
		<h1>No supported files found in pss_import.</h1>
		return;
	}

	<KeyboardShortcuts CtrlA="@SelectAll" Esc="@ClearChecks"/>
	
	<header style="visibility: @(!String.IsNullOrWhiteSpace(headerMsg) || selectedItems.Count > 0 ? "visible" : "hidden")">
		<button style="visibility: @(selectedItems.Count > 0 ? "visible" : "hidden")" class="iconBtn" @onclick="@ClearChecks"><span class="material-icons">close</span></button>
		<span style="visibility: @(selectedItems.Count > 0 ? "visible" : "hidden")">@selectedItems.Count&nbsp;&nbsp;Selected</span>

		<span style="visibility: @(String.IsNullOrWhiteSpace(headerMsg) ? "hidden" : "visible")" id="headerMsg">@headerMsg</span>
		
		<div id="buttons" style="visibility: @(selectedItems.Count > 0 ? "visible" : "hidden")">
			<button class="iconBtn" @onclick="@DeleteSelected"><svg width="24px" height="24px" class="material-icons" viewBox="0 0 24 24"><path d="M15 4V3H9v1H4v2h1v13c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V6h1V4h-5zm2 15H7V6h10v13zM9 8h2v9H9zm4 0h2v9h-2z"></path></svg></button>
		</div>
		
		<div id="yearWarnInputs">
			<input id="yearCheck" type="checkbox" @bind="@yearCheckEnabled"/>
			<label for="yearCheck">Enable Year Check</label>
			
			@if (yearCheckEnabled)
			{
				<input type="text" @bind="@minYear" placeholder="Min Year"/>
				<input type="text" @bind="@maxYear" placeholder="Max Year"/>
			}
		</div>
		
		<button id="clearDTBtn" class="textBtn">
			<span class="material-icons-outlined">dangerous</span>
			<span>Clear DT</span>
		</button>
	</header>
	
	<div id="mainDiv" style="top: @(!String.IsNullOrWhiteSpace(headerMsg) || selectedItems.Count > 0 ? 60 : 0)px">
		@for (int i = 0; i < importFiles.Count; i++)
		{
			if (i + 1 < importFiles.Count && importFiles[i].originalFilename == importFiles[i + 1].originalFilename && importFiles[i].extension == importFiles[i + 1].extension)
			{
				<div class="errorDiv">
					@do
					{
						<ListItem OnCheckClick="@StateHasChanged" Index="@i" ImportFile="@importFiles[i]"/>
						i++;
					} while (i < importFiles.Count && importFiles[i - 1].originalFilename == importFiles[i].originalFilename);
					@{ i--; } @* Kind of stupid but fixes a problem where some items could be skipped. *@
				</div>
			}
			else
			{
				<ListItem OnCheckClick="@StateHasChanged" Index="@i" ImportFile="@importFiles[i]"/>
			}
		}
	</div>
}

@code {
	private bool finishedRendering;

	///Used to show error or other messages in the header.
	private string headerMsg;

	///If Import should check the DT year of each item to see if it's outside of a range of valid values.
	public static bool yearCheckEnabled = true;

	///Show a warning if any items have a DT year less than or greater than these values.
	public static int minYear, maxYear;

	///Stores the absolute path of every supported file in pss_import.
	private List<string> allAbsPaths;

	///List of data about each supported file in pss_import.
	public static List<ImportFile> importFiles;

	///Stores what items are selected by the user.
	public static readonly HashList<Guid> selectedItems = new();

	///When a user checks a checkbox, what is the last one they clicked? Used for shift clicking.
	public static int lastCheckedIndex = 0;

	private int errorAmount;

	protected override async Task OnInitializedAsync()
	{
		allAbsPaths = F.GetSupportedFiles(S.importFolderPath);
		importFiles = new List<ImportFile>(allAbsPaths.Count);
		selectedItems.Clear();
		minYear = 2000;
		maxYear = DateTime.Today.Year;

		await Parallel.ForEachAsync(allAbsPaths, async (absPath, _) =>
		{
			ImportFile importFile = new(absPath);
			importFiles.Add(importFile);
		});
		
		OrganizeItems();
		finishedRendering = true;
		StateHasChanged();
	}

	///Organizes the import items by putting the errors at the top of the page above the other files.
	private void OrganizeItems()
	{
		errorAmount = 0;
		List<ImportFile> errors = new(), good = new();

		importFiles = importFiles.OrderBy(file => file.originalFilename).ToList();
		for (int i = 0; i < importFiles.Count; i++)
		{
			if (i + 1 < importFiles.Count && importFiles[i].originalFilename == importFiles[i + 1].originalFilename && importFiles[i].extension == importFiles[i + 1].extension)
			{
				errorAmount++;
				
				do
				{
					errors.Add(importFiles[i]);
					i++;
				} while (i < importFiles.Count && importFiles[i - 1].originalFilename == importFiles[i].originalFilename && importFiles[i - 1].extension == importFiles[i].extension);
				i--; //Kind of stupid but fixes a problem where some items could be skipped because of the i++.
			}
			else
			{
				good.Add(importFiles[i]);
			}
		}

		importFiles = errors.Concat(good).ToList();
		headerMsg = errorAmount > 0 ? $"{errorAmount} Filename Errors" : "";
	}

	private void ClearChecks()
	{
		selectedItems.Clear();
		StateHasChanged();
	}

	private void SelectAll()
	{
		foreach (ImportFile file in importFiles)
			selectedItems.Add(file.uuid);
		StateHasChanged();
	}
	
	private void DeleteSelected()
	{
		foreach (ImportFile file in importFiles.Where(file => selectedItems.Contains(file.uuid)).ToList())
		{
			FileSystem.DeleteFile(file.absolutePath, UIOption.OnlyErrorDialogs, RecycleOption.SendToRecycleBin);
			importFiles.RemoveAll(f => selectedItems.Contains(f.uuid));
		}
		ClearChecks();
		OrganizeItems();
		StateHasChanged();
	}
}