@page "/"
@using Microsoft.VisualBasic.FileIO
@inject IJSRuntime JSRuntime

<title>Import - PSS</title>
<link href="css/Import.css" rel="stylesheet">

@{
	if (!finishedRendering)
		return;
	
	if (allAbsPaths is null || allAbsPaths.Count is 0)
	{
		<h1>No supported files found in pss_import.</h1>
		return;
	}
	
	<header style="visibility: @(!String.IsNullOrWhiteSpace(headerMsg) || selectedItems.Count > 0 ? "visible" : "hidden")">
		<button style="visibility: @(selectedItems.Count > 0 ? "visible" : "hidden")" class="iconBtn" @onclick="@ClearChecks"><span class="material-icons">close</span></button>
		<span style="visibility: @(selectedItems.Count > 0 ? "visible" : "hidden")">@selectedItems.Count&nbsp;&nbsp;Selected</span>

		<span style="visibility: @(String.IsNullOrWhiteSpace(headerMsg) ? "hidden" : "visible")" id="headerMsg">@headerMsg</span>
		
		<div id="buttons" style="visibility: @(selectedItems.Count > 0 ? "visible" : "hidden")">
			<button class="iconBtn" @onclick="@DeleteSelected"><svg width="24px" height="24px" class="material-icons" viewBox="0 0 24 24"><path d="M15 4V3H9v1H4v2h1v13c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V6h1V4h-5zm2 15H7V6h10v13zM9 8h2v9H9zm4 0h2v9h-2z"></path></svg></button>
		</div>
	</header>
	
	<div id="mainDiv" style="top: @(!String.IsNullOrWhiteSpace(headerMsg) || selectedItems.Count > 0 ? 60 : 0)px">
		@for (int i = 0; i < importFiles.Count; i++)
		{
			if (i + 1 < importFiles.Count && importFiles[i].originalFilename == importFiles[i + 1].originalFilename && importFiles[i].extension == importFiles[i + 1].extension)
			{
				<div class="errorDiv">
					@do
					{
						int ii = i;
						<div class="listItem">
							<span class="material-icons-outlined checkbox unchecked" id="@importFiles[i].uuid" @onclick="@(eventArgs => CheckClicked(eventArgs, importFiles[ii].uuid, ii))">check_circle</span>
							<img src=@(importFiles[i].thumbnail == null ? $"pss_import/{importFiles[i].shortPath}" : $"data:image/jpg;base64,{importFiles[i].thumbnail}") onclick="window.open('pss_import/@importFiles[i].shortPath', '_blank').focus();" alt="" loading="lazy"/>
							<span class="shortPath" ondblclick="openEdit(@i)">@importFiles[i].shortPath</span>
							<input type="text" @bind="@importFiles[ii].renamedFilename" style="display: none" id="text @i">
							<button class="iconBtn" id="save @i" @onclick="@(() => FilenameChanged(ii))" style="display: none"><span class="material-icons-outlined">save</span></button>
							<button class="iconBtn" id="close @i" onclick="closeEdit(@i)" style="display: none"><span class="material-icons-outlined">close</span></button>
						</div>
						i++;
					} while (i < importFiles.Count && importFiles[i - 1].originalFilename == importFiles[i].originalFilename);
					@{ i--; } @* Kind of stupid but fixes a problem where some items could be skipped. *@
				</div>
			}
			else
			{
				int ii = i;
				<div class="listItem">
					<span class="material-icons-outlined checkbox unchecked" id="@importFiles[i].uuid" @onclick="@(eventArgs => CheckClicked(eventArgs, importFiles[ii].uuid, ii))">check_circle</span>
					<img src=@(importFiles[i].thumbnail == null ? $"pss_import/{importFiles[i].shortPath}" : $"data:image/jpg;base64,{importFiles[i].thumbnail}") onclick="window.open('pss_import/@importFiles[i].shortPath', '_blank').focus();" alt="" loading="lazy"/>
					<span class="shortPath" ondblclick="openEdit(@i)">@importFiles[i].shortPath</span>
					<input type="text" @bind="@importFiles[ii].renamedFilename" style="display: none" id="text @i">
					<button class="iconBtn" id="save @i" @onclick="@(() => FilenameChanged(ii))" style="display: none"><span class="material-icons-outlined">save</span></button>
					<button class="iconBtn" id="close @i" onclick="closeEdit(@i)" style="display: none"><span class="material-icons-outlined">close</span></button>
				</div>
			}
		}
	</div>
}

@code {

	private bool finishedRendering;

	///Used to show error or other messages in the header.
	private string headerMsg;

	///Stores the absolute path of every supported file in pss_import.
	private List<string> allAbsPaths;

	///List of data about each supported file in pss_import.
	private List<ImportFile> importFiles;

	///Stores what items are selected by the user.
	private readonly HashList<Guid> selectedItems = new();

	///When a user checks a checkbox, what is the last one they clicked? Used for shift clicking.
	private int lastCheckedIndex;

	private int errorAmount;

	protected override async Task OnInitializedAsync()
	{
		allAbsPaths = F.GetSupportedFiles(S.importFolderPath);
		importFiles = new List<ImportFile>(allAbsPaths.Count);

		await Parallel.ForEachAsync(allAbsPaths, async (absPath, _) =>
		{
			ImportFile importFile = new(absPath);
			importFiles.Add(importFile);
		});
		
		OrganizeItems();
		finishedRendering = true;
		StateHasChanged();
	}

	///Organizes the import items by putting the errors at the top of the page above the other files.
	private void OrganizeItems()
	{
		errorAmount = 0;
		List<ImportFile> errors = new(), good = new();

		importFiles = importFiles.OrderBy(file => file.originalFilename).ToList();
		for (int i = 0; i < importFiles.Count; i++)
		{
			if (i + 1 < importFiles.Count && importFiles[i].originalFilename == importFiles[i + 1].originalFilename && importFiles[i].extension == importFiles[i + 1].extension)
			{
				errorAmount++;
				
				do
				{
					errors.Add(importFiles[i]);
					i++;
				} while (i < importFiles.Count && importFiles[i - 1].originalFilename == importFiles[i].originalFilename && importFiles[i - 1].extension == importFiles[i].extension);
				i--; //Kind of stupid but fixes a problem where some items could be skipped because of the i++.
			}
			else
			{
				good.Add(importFiles[i]);
			}
		}

		importFiles = errors.Concat(good).ToList();
		headerMsg = errorAmount > 0 ? $"{errorAmount} Filename Errors" : "";
	}

	private void FilenameChanged(int index)
	{
		const string DUPE_ERROR_MSG = "File with same name in folder.";
		ImportFile file = importFiles[index];
		if (file.originalFilename == file.renamedFilename || file.renamedFilename == DUPE_ERROR_MSG)
		{
			JSRuntime.InvokeAsync<int>("closeEdit", index);
			file.renamedFilename = file.originalFilename;
			return;
		}
		
		string newShortPath = file.shortPath.Replace(file.originalFilename, file.renamedFilename);
		string newPath = Path.Join(S.importFolderPath, newShortPath);
		if (!newPath.EndsWith(file.extension))
			newPath += file.extension;
		
		if (File.Exists(newPath))
		{
			file.renamedFilename = DUPE_ERROR_MSG;
		}
		else
		{
			File.Move(file.absolutePath, newPath);
			JSRuntime.InvokeAsync<int>("closeEdit", index);
			file.originalFilename = file.renamedFilename;
			file.shortPath = newShortPath;
		}
	}

	#region Checkbox Methods
	///Called when the check for an item is clicked, or when an item is clicked and Ctrl is down or there is at least 1 item selected. Toggles that item's check, or multiple items if Shift is held down.
	private async Task CheckClicked(MouseEventArgs eventArgs, Guid listItemId, int index)
	{
		await ToggleCheck(listItemId);

		//Get if Shift was held down when clicking the checkbox. Used for selecting multiple items.
		if (eventArgs.ShiftKey)
		{
			//First item is on left and item shift clicked is on the right. E.g., ###1####2### Loop from 1 --> 2, and add stuff in between to selectedItems.
			if (lastCheckedIndex < index)
				await AddSelected(lastCheckedIndex, index);
			else if (lastCheckedIndex > index) //Same as above but swap 1 and 2 and the direction.
				await AddSelected(index, lastCheckedIndex);
		}
		else
		{
			lastCheckedIndex = index;
		}
		
		//Modifies a checkmark's CSS class to show if checked/unchecked, and adds/removes the uuid from selectedItems.
		async Task ToggleCheck(Guid uuid)
		{
			string newClass = await JSRuntime.InvokeAsync<string>("toggleCheck", uuid);
			if (newClass.Contains("unchecked")) //No longer selected.
			{
				selectedItems.Remove(uuid);
			}
			else if (!selectedItems.Contains(uuid)) //Needed to prevent adding dupes when shift clicking.
			{
				selectedItems.Add(uuid);
			}
		}
	
		//Add items from start to end into selectedItems. Used for Shift Click.
		async Task AddSelected(int startIndex, int endIndex)
		{
			for (int i = startIndex; i <= endIndex; i++)
			{
				Guid currentID = importFiles[i].uuid;
				if (!selectedItems.Contains(currentID)) await ToggleCheck(currentID);
			}
		}
	}
	
	private async Task ClearChecks()
	{
		foreach (Guid item in selectedItems)
			await JSRuntime.InvokeAsync<string>("removeCheck", item);
		selectedItems.Clear();
	}
	#endregion
	
	private async void DeleteSelected()
	{
		foreach (ImportFile file in importFiles.Where(file => selectedItems.Contains(file.uuid)).ToList())
		{
			FileSystem.DeleteFile(file.absolutePath, UIOption.OnlyErrorDialogs, RecycleOption.SendToRecycleBin);
			importFiles.RemoveAll(f => selectedItems.Contains(f.uuid));
		}
		await ClearChecks();
		OrganizeItems();
		StateHasChanged();
	}
}