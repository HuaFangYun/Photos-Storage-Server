@page "/"
@using Microsoft.VisualBasic.FileIO

<title>Import - PSS</title>
<link href="css/Import.css" rel="stylesheet">

@{
	if (!finishedRendering)
		return;
	
	if (allAbsPaths is null || allAbsPaths.Count is 0)
	{
		<h1>No supported files found in pss_import.</h1>
		return;
	}

	<KeyboardShortcuts CtrlA="@SelectAll" Esc="@ClearChecks" Slash="@FocusSearchInput"/>
	
	<header style="visibility: @(errorAmount > 0 || selectedItems.Count > 0 ? "visible" : "hidden")">
		<button style="visibility: @(selectedItems.Count > 0 ? "visible" : "hidden")" class="iconBtn" @onclick="@ClearChecks"><span class="material-icons">close</span></button>
		<span style="visibility: @(selectedItems.Count > 0 ? "visible" : "hidden")">@selectedItems.Count&nbsp;&nbsp;Selected</span>

		<div id="statsDiv">
			<span>@(searchResults.Count > 0 || !String.IsNullOrWhiteSpace(searchText) ? $"{searchResults.Count} Results" : $"{importFiles.Count} Files")</span>
			<span style="visibility: @(errorAmount > 0 ? "visible" : "hidden")" id="errorAmount">@errorAmount Filename Errors</span>
		</div>
		
		<button id="clearDTBtn" class="textBtn" @onclick="@ClearDateTaken" style="visibility: @(selectedItems.Count > 0 ? "visible" : "hidden")"><span class="material-icons-outlined">dangerous</span><span>Clear DT</span></button>
        
        <input @ref="@searchInput" id="search" type="text" @bind="@searchText" @bind:event="oninput" @onkeydown="@(e => { if (e.Code is "Enter" or "NumpadEnter") SearchItems(); })" @onfocusout="@SearchItems" placeholder="Search original/renamed filenames"/>
		
		<div id="yearWarnInputs">
			<input id="yearCheck" type="checkbox" @bind="@yearCheckEnabled"/>
			<label for="yearCheck">Year Check</label>
			
			@if (yearCheckEnabled)
			{
				<input type="text" @bind="@minYear" placeholder="Min Year"/>
				<input type="text" @bind="@maxYear" placeholder="Max Year"/>
			}
		</div>
		
		<div id="buttons" style="visibility: @(selectedItems.Count > 0 ? "visible" : "hidden")">
        	<button class="iconBtn" @onclick="@DeleteSelected"><svg width="24px" height="24px" class="material-icons" viewBox="0 0 24 24"><path d="M15 4V3H9v1H4v2h1v13c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V6h1V4h-5zm2 15H7V6h10v13zM9 8h2v9H9zm4 0h2v9h-2z"></path></svg></button>
        </div>
	</header>
	
	<div id="mainDiv" style="top: @(errorAmount > 0 || selectedItems.Count > 0 ? 60 : 0)px">
		@for (int i = 0; i < importFiles.Count; i++)
		{
			if (!String.IsNullOrWhiteSpace(searchText) && !searchResults.Contains(importFiles[i].uuid)) continue;
			
			if (i + 1 < importFiles.Count && importFiles[i].originalFilename == importFiles[i + 1].originalFilename && importFiles[i].extension == importFiles[i + 1].extension)
			{
				<div class="errorDiv">
					@do
					{
						<ListItem OnCheckClick="@StateHasChanged" Index="@i" ImportFile="@importFiles[i]"/>
						i++;
					} while (i < importFiles.Count && importFiles[i - 1].originalFilename == importFiles[i].originalFilename);
					@{ i--; } @* Kind of stupid but fixes a problem where some items could be skipped. *@
				</div>
			}
			else
			{
				<ListItem OnCheckClick="@StateHasChanged" Index="@i" ImportFile="@importFiles[i]"/>
			}
		}
	</div>
}

@code {
	ElementReference searchInput;

	private bool finishedRendering;

	///If Import should check the DT year of each item to see if it's outside of a range of valid values.
	private bool yearCheckEnabled = true;

	///Show a warning if any items have a DT year less than or greater than these values.
	public static int minYear, maxYear;

	///Stores the absolute path of every supported file in pss_import.
	private List<string> allAbsPaths;

	///List of data about each supported file in pss_import.
	public static List<ImportFile> importFiles;

	///If the user does a search, store the results as the uuids of the items.
	private readonly HashList<Guid> searchResults = new();

	///Stores what items are selected by the user.
	public static readonly HashList<Guid> selectedItems = new();

	///When a user checks a checkbox, what is the last one they clicked? Used for shift clicking.
	public static int lastCheckedIndex = 0;

	private int errorAmount;

	private string searchText;

	protected override async Task OnInitializedAsync()
	{
		allAbsPaths = F.GetSupportedFiles(S.importFolderPath);
		importFiles = new List<ImportFile>(allAbsPaths.Count);
		searchResults.Clear();
		selectedItems.Clear();
		minYear = 2000;
		maxYear = DateTime.Today.Year;

		await Parallel.ForEachAsync(allAbsPaths, async (absPath, _) =>
		{
			ImportFile importFile = new(absPath);
			importFiles.Add(importFile);
		});
		
		OrganizeItems();
		finishedRendering = true;
		StateHasChanged();
	}

	///Organizes the import items by putting the errors at the top of the page above the other files.
	private void OrganizeItems()
	{
		errorAmount = 0;
		List<ImportFile> errors = new(), good = new();

		importFiles = importFiles.OrderBy(file => file.originalFilename).ToList();
		for (int i = 0; i < importFiles.Count; i++)
		{
			if (i + 1 < importFiles.Count && importFiles[i].originalFilename == importFiles[i + 1].originalFilename && importFiles[i].extension == importFiles[i + 1].extension)
			{
				errorAmount++;
				
				do
				{
					errors.Add(importFiles[i]);
					i++;
				} while (i < importFiles.Count && importFiles[i - 1].originalFilename == importFiles[i].originalFilename && importFiles[i - 1].extension == importFiles[i].extension);
				i--; //Kind of stupid but fixes a problem where some items could be skipped because of the i++.
			}
			else
			{
				good.Add(importFiles[i]);
			}
		}

		importFiles = errors.Concat(good).ToList();
	}

	private void SearchItems()
	{
		searchResults.Clear();
		if (String.IsNullOrWhiteSpace(searchText)) return;
		
		foreach (ImportFile file in importFiles)
		{
			if (file.renamedFilename.IndexOf(searchText, StringComparison.InvariantCultureIgnoreCase) != -1 || file.originalFilename.IndexOf(searchText, StringComparison.InvariantCultureIgnoreCase) != -1)
				searchResults.Add(file.uuid);
		}
	}

	private void ClearChecks()
	{
		if (searchResults.Count > 0)
		{
			foreach (Guid uuid in searchResults)
				selectedItems.Remove(uuid);
		}
		else
		{
			selectedItems.Clear();
		}
		StateHasChanged();
	}

	///Either adds all search results to selectedItems, or adds every ImportFile to selectedItems.
	private void SelectAll()
	{
		if (searchResults.Count > 0)
		{
			foreach (Guid uuid in searchResults)
				selectedItems.Add(uuid);
		}
		else
		{
			foreach (ImportFile file in importFiles)
				selectedItems.Add(file.uuid);
		}
		StateHasChanged();
	}
	
	///Sends all selected files to the Recycle Bin.
	private void DeleteSelected()
	{
		foreach (ImportFile file in importFiles.Where(file => selectedItems.Contains(file.uuid)).ToList())
		{
			FileSystem.DeleteFile(file.absolutePath, UIOption.OnlyErrorDialogs, RecycleOption.SendToRecycleBin);
			importFiles.RemoveAll(f => selectedItems.Contains(f.uuid));
		}
		ClearChecks();
		OrganizeItems();
		StateHasChanged();
	}

	private void ClearDateTaken()
	{
		foreach (ImportFile file in importFiles.Where(file => selectedItems.Contains(file.uuid)).ToList())
		{
			file.dateTakenSource = ImportFile.DateTakenSource.Custom;
			file.customDateTaken = null;
		}
	}

	private async void FocusSearchInput() => await searchInput.FocusAsync();
}