@page "/"
@inject IJSRuntime JSRuntime

<title>Import - PSS</title>
<link href="css/Import.css" rel="stylesheet">

@{
	if (!finishedRendering)
		return;
	
	if (allAbsPaths is null || allAbsPaths.Count is 0)
	{
		<h1>No supported files found in pss_import.</h1>
		return;
	}
	
	<div id="mainDiv">
		@for (int i = 0; i < importFiles.Count; i++)
		{
			if (i + 1 < importFiles.Count && importFiles[i].originalFilename == importFiles[i + 1].originalFilename && importFiles[i].extension == importFiles[i + 1].extension)
			{
				<div class="errorDiv">
					@do
					{
						int ii = i;
						<div class="listItem">
							<img src=@(importFiles[i].thumbnail == null ? $"pss_import/{importFiles[i].shortPath}" : $"data:image/jpg;base64,{importFiles[i].thumbnail}") onclick="window.open('pss_import/@importFiles[i].shortPath', '_blank').focus();" alt="" loading="lazy"/>
							<span>@importFiles[i].shortPath</span>
							<button class="iconBtn" id="edit @i" onclick="openEdit(@i)"><span class="material-icons-outlined">edit</span></button>
                            <input type="text" @bind="@importFiles[ii].renamedFilename" style="display: none" id="text @i">
							<button class="iconBtn" id="save @i" @onclick="@(() => FilenameChanged(ii))" style="display: none"><span class="material-icons-outlined">save</span></button>
							<button class="iconBtn" id="close @i" onclick="closeEdit(@i)" style="display: none"><span class="material-icons-outlined">close</span></button>
						</div>
						i++;
					} while (i < importFiles.Count && importFiles[i - 1].originalFilename == importFiles[i].originalFilename);
					@{ i--; } @* Kind of stupid but fixes a problem where some items could be skipped. *@
				</div>
			}
			else
			{
				int ii = i;
				<div class="listItem">
					<img src=@(importFiles[i].thumbnail == null ? $"pss_import/{importFiles[i].shortPath}" : $"data:image/jpg;base64,{importFiles[i].thumbnail}") onclick="window.open('pss_import/@importFiles[i].shortPath', '_blank').focus();" alt="" loading="lazy"/>
					<span>@importFiles[i].shortPath</span>
					<button class="iconBtn" id="edit @i" onclick="openEdit(@i)"><span class="material-icons-outlined">edit</span></button>
					<input type="text" @bind="@importFiles[ii].renamedFilename" style="display: none" id="text @i">
					<button class="iconBtn" id="save @i" @onclick="@(() => FilenameChanged(ii))" style="display: none"><span class="material-icons-outlined">save</span></button>
					<button class="iconBtn" id="close @i" onclick="closeEdit(@i)" style="display: none"><span class="material-icons-outlined">close</span></button>
				</div>
			}
		}
	</div>

	if (errorAmount > 0)
		return;
	
	<span>shouldn't see me</span>
}

@code {

	private static bool finishedRendering;

	///Stores the absolute path of every supported file in pss_import.
	private static List<string> allAbsPaths;

	///List of data about each supported file in pss_import.
	private static List<ImportFile> importFiles;

	private static int errorAmount;

	protected override async Task OnInitializedAsync()
	{
		allAbsPaths = F.GetSupportedFiles(S.importFolderPath);
		importFiles = new List<ImportFile>(allAbsPaths.Count);

		await Parallel.ForEachAsync(allAbsPaths, async (absPath, _) =>
		{
			ImportFile importFile = new(absPath);
			importFiles.Add(importFile);
		});
		
		PrepareData();
		finishedRendering = true;
		StateHasChanged();
	}

	private static void PrepareData()
	{
		List<ImportFile> errors = new(), good = new();

		importFiles = importFiles.OrderBy(file => file.originalFilename).ToList();
		for (int i = 0; i < importFiles.Count; i++)
		{
			if (i + 1 < importFiles.Count && importFiles[i].originalFilename == importFiles[i + 1].originalFilename && importFiles[i].extension == importFiles[i + 1].extension)
			{
				errorAmount++;
				
				do
				{
					errors.Add(importFiles[i]);
					i++;
				} while (i < importFiles.Count && importFiles[i - 1].originalFilename == importFiles[i].originalFilename && importFiles[i - 1].extension == importFiles[i].extension);
				i--; //Kind of stupid but fixes a problem where some items could be skipped because of the i++.
			}
			else
			{
				good.Add(importFiles[i]);
			}
		}

		importFiles = errors.Concat(good).ToList();
	}

	private void FilenameChanged(int index)
	{
		const string DUPE_ERROR_MSG = "File with same name in folder.";
		ImportFile file = importFiles[index];
		if (file.originalFilename == file.renamedFilename || file.renamedFilename == DUPE_ERROR_MSG)
		{
			JSRuntime.InvokeAsync<int>("closeEdit", index);
			file.renamedFilename = file.originalFilename;
			return;
		}
		
		string newShortPath = file.shortPath.Replace(file.originalFilename, file.renamedFilename);
		string newPath = Path.Join(S.importFolderPath, newShortPath);
		if (!newPath.EndsWith(file.extension))
			newPath += file.extension;
		
		if (File.Exists(newPath))
		{
			file.renamedFilename = DUPE_ERROR_MSG;
		}
		else
		{
			File.Move(file.absolutePath, newPath);
			JSRuntime.InvokeAsync<int>("closeEdit", index);
			file.originalFilename = file.renamedFilename;
			file.shortPath = newShortPath;
		}
	}
}