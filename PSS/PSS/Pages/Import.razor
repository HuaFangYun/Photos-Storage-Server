@page "/"
@using Microsoft.VisualBasic.FileIO

<title>Import - PSS</title>
<link href="css/Import.css" rel="stylesheet">

@{
	if (!finishedLoading)
		return;
	
	if (allAbsPaths is null || allAbsPaths.Count is 0)
	{
		<h1>No supported files found in pss_import.</h1>
		return;
	}

	<KeyboardShortcuts CtrlA="@SelectAll" Esc="@ClearChecks" Slash="@FocusSearchInput"/>
	
	<header>
		<button style="visibility: @(selectedItems.Count > 0 ? "visible" : "hidden")" class="iconBtn" @onclick="@ClearChecks"><span class="material-icons">close</span></button>
		<span style="visibility: @(selectedItems.Count > 0 ? "visible" : "hidden")">@selectedItems.Count&nbsp;&nbsp;Selected</span>

		<div id="statsDiv">
			<span>@(searchResults.Count > 0 || !String.IsNullOrWhiteSpace(searchText) ? $"{searchResults.Count} Results" : $"{importFiles.Count} Files")</span>
			<span style="visibility: @(errorAmount > 0 ? "visible" : "hidden")" id="errorAmount">@errorAmount Filename Errors</span>
		</div>
		
		<button id="clearDTBtn" class="textBtn" @onclick="@ClearDateTaken" style="visibility: @(selectedItems.Count > 0 ? "visible" : "hidden")"><span class="material-icons-outlined">dangerous</span><span>Clear DT</span></button>
        
        <input @ref="@searchInput" id="search" type="text" @bind="@searchText" @bind:event="oninput" @onkeydown="@(e => { if (e.Code is "Enter" or "NumpadEnter") SearchItems(); })" @onfocusout="@SearchItems" placeholder="Search original/renamed filenames"/>
		
		<div id="yearWarnInputs">
			<input id="yearCheck" type="checkbox" @bind="@yearCheckEnabled"/>
			<label for="yearCheck">Year Check</label>
			
			@if (yearCheckEnabled)
			{
				<input type="text" @bind="@minYear" placeholder="Min Year"/>
				<input type="text" @bind="@maxYear" placeholder="Max Year"/>
			}
		</div>
		
		<div id="buttons" style="visibility: @(selectedItems.Count > 0 ? "visible" : "hidden")">
        	<button class="iconBtn" @onclick="@DeleteSelected"><svg width="24px" height="24px" class="material-icons" viewBox="0 0 24 24"><path d="M15 4V3H9v1H4v2h1v13c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V6h1V4h-5zm2 15H7V6h10v13zM9 8h2v9H9zm4 0h2v9h-2z"></path></svg></button>
        </div>
	</header>
	
	<div id="mainDiv" style="top: @(errorAmount > 0 || selectedItems.Count > 0 ? 60 : 0)px">
		@for (int i = 0; i < importFiles.Count; i++)
		{
			if (!String.IsNullOrWhiteSpace(searchText) && !searchResults.Contains(importFiles[i].uuid)) continue;
			
			if (i + 1 < importFiles.Count && importFiles[i].originalFilename == importFiles[i + 1].originalFilename && importFiles[i].extension == importFiles[i + 1].extension)
			{
				<div class="errorDiv">
					@do
					{
						<ImportItem Rerender="@StateHasChanged" Index="@i"/>
						i++;
					} while (i < importFiles.Count && importFiles[i - 1].originalFilename == importFiles[i].originalFilename);
					@{ i--; } @* Kind of stupid but fixes a problem where some items could be skipped. *@
					
					@if (libFilesWithSameName.ContainsKey(importFiles[i].originalFilename))
					{
						foreach (C.MediaRow mediaRow in libFilesWithSameName[importFiles[i].originalFilename])
						{
							<LibraryItem MediaRow="@mediaRow"/>
						}
					}
				</div>
			}
			else if (libFilesWithSameName.ContainsKey(importFiles[i].originalFilename))
			{
				<div class="errorDiv">
					<ImportItem Rerender="@StateHasChanged" Index="@i"/>
					@foreach (C.MediaRow mediaRow in libFilesWithSameName[importFiles[i].originalFilename])
					{
						<LibraryItem MediaRow="@mediaRow"/>
					}
				</div>
			}
			else
			{
				<ImportItem Rerender="@StateHasChanged" Index="@i"/>
			}
		}
	</div>
}

@code {
	private static ElementReference searchInput;

	private static bool finishedLoading;

	///If Import should check the DT year of each item to see if it's outside of a range of valid values.
	private static bool yearCheckEnabled = true;

	///Show a warning if any items have a DT year less than or greater than these values.
	public static int minYear, maxYear;

	///Stores the absolute path of every supported file in pss_import.
	private static List<string> allAbsPaths;

	///List of data about each supported file in pss_import.
	public static List<ImportFile> importFiles;

	private static readonly LazyDictionary<string, List<C.MediaRow>> libFilesWithSameName = new();

	///If the user does a search, store the results as the uuids of the items.
	private static readonly HashList<Guid> searchResults = new();

	///Stores what items are selected by the user.
	public static readonly HashList<Guid> selectedItems = new();

	///When a user checks a checkbox, what is the last one they clicked? Used for shift clicking.
	public static int lastCheckedIndex = 0;

	private static int errorAmount;

	private static string searchText;

	protected override async Task OnInitializedAsync()
	{
		allAbsPaths = F.GetSupportedFiles(S.importFolderPath);
		importFiles = new List<ImportFile>(allAbsPaths.Count);
		libFilesWithSameName.Clear();
		searchResults.Clear();
		selectedItems.Clear();
		minYear = 2000;
		maxYear = DateTime.Today.Year;
		errorAmount = 0;

		await Parallel.ForEachAsync(allAbsPaths, async (absPath, _) =>
		{
			ImportFile importFile = new(absPath);
			importFiles.Add(importFile);
		});
		
		OrganizeItems();
		finishedLoading = true;
		StateHasChanged();
	}

	///Organizes the import items by putting the errors at the top of the page above the other files.
	public static void OrganizeItems()
	{
		errorAmount = 0;
		List<ImportFile> errors = new(), good = new();
		libFilesWithSameName.Clear();

		importFiles = importFiles.OrderBy(file => file.originalFilename).ToList();
		for (int i = 0; i < importFiles.Count; i++)
		{
			/* List<C.MediaRow> result = FindLibraryFilesWithSameName(importFiles[i].originalFilename); //TODO alternative
			// if (result?.Count > 0 && !libFilesWithSameName.ContainsKey(importFiles[i].originalFilename))
				// libFilesWithSameName.Add(importFiles[i].originalFilename, result); */

			if (!libFilesWithSameName.ContainsKey(importFiles[i].originalFilename))
			{
				List<C.MediaRow> result = FindLibraryFilesWithSameName(importFiles[i].originalFilename + importFiles[i].extension);
				if (result?.Count > 0)
				{
					libFilesWithSameName.Add(importFiles[i].originalFilename, result);
					errorAmount++;
				}
			}

			if (i + 1 < importFiles.Count && importFiles[i].originalFilename == importFiles[i + 1].originalFilename && importFiles[i].extension == importFiles[i + 1].extension)
			{
				errorAmount++;
				
				do
				{
					errors.Add(importFiles[i]);
					i++;
				} while (i < importFiles.Count && importFiles[i - 1].originalFilename == importFiles[i].originalFilename && importFiles[i - 1].extension == importFiles[i].extension);
				i--; //Kind of stupid but fixes a problem where some items could be skipped because of the i++.
			}
			else
			{
				good.Add(importFiles[i]);
			}
		}

		importFiles = errors.Concat(good).OrderByDescending(file => libFilesWithSameName[file.originalFilename]?.Count).ToList();
	}
    
	///Searches the database for items with the same filename and returns a List&lt;MediaRow&gt; of the DB items.
	private static List<C.MediaRow> FindLibraryFilesWithSameName(string filenameWithExt)
	{
		C.Open();
		using NpgsqlCommand cmd = new($"SELECT path, date_taken, thumbnail FROM media WHERE path LIKE '%{filenameWithExt}' ORDER BY date_taken DESC", C.connection);
		cmd.ExecuteNonQuery();
		using NpgsqlDataReader r = cmd.ExecuteReader();
		if (!r.HasRows) return null;

		List<C.MediaRow> result = new();
		while (r.Read())
		{
			string path = r.GetString(0);
			if (Path.GetFileName(path) == filenameWithExt)
				result.Add(new C.MediaRow(path, r.IsDBNull(1) ? null : r.GetDateTime(1), r.IsDBNull(2) ? null : r.GetString(2)));
		}
		r.Close();
		C.Close();
		return result;
	}

	///Searches the database for items with similar filenames and returns a List&lt;MediaRow&gt; of the DB items.
	public static List<C.MediaRow> FindLibraryFilesWithSimilarName(string filenameNoExt)
	{
		C.Open();
		using NpgsqlCommand cmd = new($"SELECT path, date_taken, thumbnail FROM media WHERE path LIKE '%{filenameNoExt}%' ORDER BY date_taken DESC", C.connection);
		cmd.ExecuteNonQuery();
		using NpgsqlDataReader r = cmd.ExecuteReader();
		if (!r.HasRows) return null;

		List<C.MediaRow> result = new();
		while (r.Read())
		{
			result.Add(new C.MediaRow(r.GetString(0), r.IsDBNull(1) ? null : r.GetDateTime(1), r.IsDBNull(2) ? null : r.GetString(2)));
		}
		r.Close();
		C.Close();
		return result;
	}

	private static void SearchItems()
	{
		searchResults.Clear();
		if (String.IsNullOrWhiteSpace(searchText)) return;
		
		foreach (ImportFile file in importFiles)
		{
			if (file.renamedFilename.IndexOf(searchText, StringComparison.InvariantCultureIgnoreCase) != -1 || file.originalFilename.IndexOf(searchText, StringComparison.InvariantCultureIgnoreCase) != -1)
				searchResults.Add(file.uuid);
		}
	}

	private void ClearChecks()
	{
		if (searchResults.Count > 0)
		{
			foreach (Guid uuid in searchResults)
				selectedItems.Remove(uuid);
		}
		else
		{
			selectedItems.Clear();
		}
		StateHasChanged();
	}

	///Either adds all search results to selectedItems, or adds every ImportFile to selectedItems.
	private void SelectAll()
	{
		if (searchResults.Count > 0)
		{
			foreach (Guid uuid in searchResults)
				selectedItems.Add(uuid);
		}
		else
		{
			foreach (ImportFile file in importFiles)
				selectedItems.Add(file.uuid);
		}
		StateHasChanged();
	}
	
	///Sends all selected files to the Recycle Bin.
	private void DeleteSelected()
	{
		foreach (ImportFile file in importFiles.Where(file => selectedItems.Contains(file.uuid)).ToList())
		{
			FileSystem.DeleteFile(file.absolutePath, UIOption.OnlyErrorDialogs, RecycleOption.SendToRecycleBin);
			importFiles.RemoveAll(f => selectedItems.Contains(f.uuid));
		}
		ClearChecks();
		OrganizeItems();
		StateHasChanged();
	}

	private static void ClearDateTaken()
	{
		foreach (ImportFile file in importFiles.Where(file => selectedItems.Contains(file.uuid)).ToList())
		{
			file.dateTakenSource = ImportFile.DateTakenSource.Custom;
			file.customDateTaken = null;
		}
	}

	private static async void FocusSearchInput() => await searchInput.FocusAsync();
}