@page "/"
@using Microsoft.VisualBasic.FileIO
@using CS = PSS.Shared.CollectionSelector;

<title>Import - PSS</title>
<link href="css/Import.css" rel="stylesheet">

@{
	if (!finishedLoading)
		return;
	
	if (allAbsPaths is null || allAbsPaths.Count is 0)
	{
		<h1>No supported files found in pss_import.</h1>
		return;
	}

	<KeyboardShortcuts AltC="@(() => { F.VisToggle(ref collectionSelectorVis); StateHasChanged(); })" AltS="@(() => { pathWidthClass = pathWidthClass == "shortWidth" ? "fullWidth" : "shortWidth"; StateHasChanged(); })" CtrlA="@SelectAll" Esc="@ClearChecks" Slash="@FocusSearchInput"/>
	
	<header>
		<button style="visibility: @(selectedItems.Count > 0 ? "visible" : "hidden")" class="iconBtn" @onclick="@ClearChecks"><span class="material-icons">close</span></button>
		<span style="visibility: @(selectedItems.Count > 0 ? "visible" : "hidden")">@selectedItems.Count&nbsp;&nbsp;Selected</span>

		<div id="statsDiv">
			<span>@(searchResults.Count > 0 || !String.IsNullOrWhiteSpace(searchText) ? $"{searchResults.Count} Results" : $"{importFiles.Count} Files")</span>
			<span style="visibility: @(errorAmount > 0 ? "visible" : "hidden")" id="errorAmount">@errorAmount Filename Errors</span>
		</div>
		
		<button id="clearDTBtn" class="textBtn" @onclick="@ClearDateTaken" style="visibility: @(selectedItems.Count > 0 ? "visible" : "hidden")"><span class="material-icons-outlined">dangerous</span><span>Clear DT</span></button>
        
        <input @ref="@searchInput" id="search" type="text" @bind="@searchText" @bind:event="oninput" @onkeydown="@(e => { if (e.Code is "Enter" or "NumpadEnter") SearchItems(); })" @onfocusout="@SearchItems" placeholder="Search original/renamed filenames"/>
		
		<button id="widthBtn" class="iconBtn" title="Switch width of paths to @(pathWidthClass == "shortWidth" ? "full" : "short")" @onclick="@(() => pathWidthClass = pathWidthClass == "shortWidth" ? "fullWidth" : "shortWidth")">
			<span class="material-icons-outlined">@(pathWidthClass == "shortWidth" ? "width_wide" : "width_full")</span>
		</button>
		
		<div id="yearWarnInputs">
			<input id="yearCheck" type="checkbox" @bind="@yearCheckEnabled"/>
			<label for="yearCheck">Year Check</label>
			
			@if (yearCheckEnabled)
			{
				<input type="text" @bind="@minYear" placeholder="Min Year"/>
				<input type="text" @bind="@maxYear" placeholder="Max Year"/>
			}
		</div>
		
		<div id="buttons" style="visibility: @(selectedItems.Count > 0 ? "visible" : "hidden")">
			<button class="iconBtn" @onclick="@ToggleStars"><span class="material-icons-outlined">star</span></button>
			<button class="iconBtn" @onclick="@(() => collectionSelectorVis = "visible")"><span class="material-icons-outlined">collections</span></button>
			<button class="iconBtn" @onclick="@DeleteSelected"><svg width="24px" height="24px" class="material-icons" viewBox="0 0 24 24"><path d="M15 4V3H9v1H4v2h1v13c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V6h1V4h-5zm2 15H7V6h10v13zM9 8h2v9H9zm4 0h2v9h-2z"></path></svg></button>
		</div>
	</header>
	
	<CollectionSelector OnCheckClicked="@UpdateCollections" @bind-CollectionsVis="@collectionSelectorVis" SelectedItems="@selectedItems"/>
	
	<div id="mainDiv">
		@for (int i = 0; i < importFiles.Count; i++)
		{
			if (!String.IsNullOrWhiteSpace(searchText) && !searchResults.Contains(importFiles[i].uuid)) continue;
			
			if (i + 1 < importFiles.Count && importFiles[i].originalFilename == importFiles[i + 1].originalFilename && importFiles[i].extension == importFiles[i + 1].extension)
			{
				<div class="itemGroup">
					<div class="errorDiv">
						@do
						{
							<ImportItem Rerender="@StateHasChanged" Index="@i"/>
							i++;
						} while (i < importFiles.Count && importFiles[i - 1].originalFilename == importFiles[i].originalFilename);
						@{ i--; } @* Kind of stupid but fixes a problem where some items could be skipped. *@
						
						@if (libFilesWithSameName.ContainsKey(importFiles[i].originalFilename))
						{
							foreach (C.MediaRow mediaRow in libFilesWithSameName[importFiles[i].originalFilename])
							{
								<LibraryItem MediaRow="@mediaRow" Rerender="@StateHasChanged"/>
							}
						}
					</div>
					<div class="warnDiv">
						@if (libFilesWithSimilarName.ContainsKey(importFiles[i].originalFilename))
	                    {
							foreach (C.MediaRow mediaRow in libFilesWithSimilarName[importFiles[i].originalFilename])
                    		{
                    			<LibraryItem MediaRow="@mediaRow" Rerender="@StateHasChanged"/>
                    		}
	                    }
					</div>
				</div>
			}
			else
			{
				bool hasRendered = false;
				bool hasErrors = libFilesWithSameName.ContainsKey(importFiles[i].originalFilename);
				bool hasWarnings = libFilesWithSimilarName.ContainsKey(importFiles[i].originalFilename);

				if (!hasErrors && !hasWarnings)
				{
					<ImportItem Rerender="@StateHasChanged" Index="@i"/>
					continue;
				}
				
				<div class="itemGroup">
					<div class="errorDiv">
						@if (hasErrors)
						{
							hasRendered = true;
							<ImportItem Rerender="@StateHasChanged" Index="@i"/>

							foreach (C.MediaRow mediaRow in libFilesWithSameName[importFiles[i].originalFilename])
							{
								<LibraryItem MediaRow="@mediaRow" Rerender="@StateHasChanged"/>
							}
						}
					</div>
					<div class="warnDiv">
						@if (hasWarnings)
						{
							if (!hasRendered)
							{
								<ImportItem Rerender="@StateHasChanged" Index="@i"/>
							}
							
							foreach (C.MediaRow mediaRow in libFilesWithSimilarName[importFiles[i].originalFilename])
							{
								<LibraryItem MediaRow="@mediaRow" Rerender="@StateHasChanged"/>
							}
						}
					</div>
				</div>
			}
		}
	</div>
}

@code {
	private static ElementReference searchInput;

	private static bool finishedLoading;

	public static string pathWidthClass;
	
	private static string collectionSelectorVis = "hidden";

	///If Import should check the DT year of each item to see if it's outside of a range of valid values.
	private static bool yearCheckEnabled = true;

	///Show a warning if any items have a DT year less than or greater than these values.
	public static int minYear, maxYear;

	///Stores the absolute path of every supported file in pss_import.
	private static List<string> allAbsPaths;

	///List of data about each supported file in pss_import.
	public static List<ImportFile> importFiles;

	private static readonly LazyDictionary<string, List<C.MediaRow>> libFilesWithSameName = new(), libFilesWithSimilarName = new();

	///If the user does a search, store the results as the uuids of the items.
	private static readonly HashSet<Guid> searchResults = new();

	///Stores what items are selected by the user.
	public static readonly HashSet<Guid> selectedItems = new();

	///When a user checks a checkbox, what is the last one they clicked? Used for shift clicking.
	public static int lastCheckedIndex = 0;

	private static int errorAmount;

	private static string searchText;

	protected override async Task OnInitializedAsync()
	{
		pathWidthClass = "shortWidth";
		allAbsPaths = F.GetSupportedFiles(S.importFolderPath);
		importFiles = new List<ImportFile>(allAbsPaths.Count);
		libFilesWithSameName.Clear();
		libFilesWithSimilarName.Clear();
		searchResults.Clear();
		selectedItems.Clear();
		minYear = 2000;
		maxYear = DateTime.Today.Year;
		errorAmount = 0;

		await Parallel.ForEachAsync(allAbsPaths, async (absPath, _) =>
		{
			ImportFile importFile = new(absPath);
			importFiles.Add(importFile);
		});
		
		OrganizeItems();
		finishedLoading = true;
		StateHasChanged();
	}

	///Organizes the import items by putting the errors at the top of the page above the other files.
	public static void OrganizeItems()
	{
		errorAmount = 0;
		List<ImportFile> errors = new(), good = new();
		libFilesWithSameName.Clear();
		libFilesWithSimilarName.Clear();

		importFiles = importFiles.OrderBy(file => file.originalFilename).ToList();
		for (int i = 0; i < importFiles.Count; i++)
		{
			FindLibraryFilesWithSameOrSimilarName(importFiles[i].originalFilename);

			if (i + 1 < importFiles.Count && importFiles[i].originalFilename == importFiles[i + 1].originalFilename && importFiles[i].extension == importFiles[i + 1].extension)
			{
				errorAmount++;
				
				do
				{
					errors.Add(importFiles[i]);
					i++;
				} while (i < importFiles.Count && importFiles[i - 1].originalFilename == importFiles[i].originalFilename && importFiles[i - 1].extension == importFiles[i].extension);
				i--; //Kind of stupid but fixes a problem where some items could be skipped because of the i++.
			}
			else
			{
				good.Add(importFiles[i]);
			}
		}

		importFiles = errors.Concat(good).OrderByDescending(file => libFilesWithSameName[file.originalFilename]?.Count).ToList();
	}

	private static void FindLibraryFilesWithSameOrSimilarName(string filenameNoExt)
	{
		C.Open();
		using NpgsqlCommand cmd = new($"SELECT path, date_taken, uuid, thumbnail, date_deleted FROM media WHERE path LIKE '%{filenameNoExt}%' ORDER BY date_taken DESC", C.connection);
		cmd.ExecuteNonQuery();
		using NpgsqlDataReader r = cmd.ExecuteReader();
		if (!r.HasRows)
		{
			r.Close();
			C.Close();
			return;
		}

		while (r.Read())
		{
			string path = r.GetString(0);
			string thisFilename = Path.GetFileNameWithoutExtension(path);
			C.MediaRow result = new(path, r.IsDBNull(1) ? null : r.GetDateTime(1), r.GetGuid(2), r.IsDBNull(3) ? null : r.GetString(3), r.IsDBNull(4) ? null : r.GetDateTime(4));
			if (filenameNoExt == thisFilename)
			{
				if (!libFilesWithSameName.ContainsKey(filenameNoExt))
					libFilesWithSameName.Add(filenameNoExt, new List<C.MediaRow> {result});
				else
					libFilesWithSameName[filenameNoExt].Add(result);
			}
			else
			{
				if (!libFilesWithSimilarName.ContainsKey(filenameNoExt))
					libFilesWithSimilarName.Add(filenameNoExt, new List<C.MediaRow> {result});
				else
					libFilesWithSimilarName[filenameNoExt].Add(result);
			}
		}
		r.Close();
		C.Close();
	}

	private static void SearchItems()
	{
		searchResults.Clear();
		if (String.IsNullOrWhiteSpace(searchText)) return;
		
		foreach (ImportFile file in importFiles)
		{
			if (file.renamedFilename.IndexOf(searchText, StringComparison.InvariantCultureIgnoreCase) != -1 || file.originalFilename.IndexOf(searchText, StringComparison.InvariantCultureIgnoreCase) != -1)
				searchResults.Add(file.uuid);
		}
	}

	private void ClearChecks()
	{
		if (searchResults.Count > 0)
		{
			foreach (Guid uuid in searchResults)
				selectedItems.Remove(uuid);
		}
		else
		{
			selectedItems.Clear();
		}
		StateHasChanged();
	}

	///Either adds all search results to selectedItems, or adds every ImportFile to selectedItems.
	private void SelectAll()
	{
		if (searchResults.Count > 0)
		{
			foreach (Guid uuid in searchResults)
				selectedItems.Add(uuid);
		}
		else
		{
			foreach (ImportFile file in importFiles)
				selectedItems.Add(file.uuid);
		}
		StateHasChanged();
	}

	///Updates the starred field of the selected items. If all have a star, removes stars from all. If some do and don't have a star, adds stars to the ones that don't. If none have a star, adds stars to all of them.
	private static void ToggleStars()
	{
		List<ImportFile> selectedFiles = importFiles.Where(file => selectedItems.Contains(file.uuid)).ToList();
		bool allStarred = selectedFiles.All(file => file.starred);

		foreach (ImportFile importFile in selectedFiles)
			importFile.starred = !allStarred;
	}
	
	///Sends all selected files to the Recycle Bin.
	private void DeleteSelected()
	{
		foreach (ImportFile file in importFiles.Where(file => selectedItems.Contains(file.uuid)).ToList())
		{
			FileSystem.DeleteFile(file.absolutePath, UIOption.OnlyErrorDialogs, RecycleOption.SendToRecycleBin);
			importFiles.RemoveAll(f => selectedItems.Contains(f.uuid));
		}
		ClearChecks();
		OrganizeItems();
		StateHasChanged();
	}

	private static void ClearDateTaken()
	{
		foreach (ImportFile file in importFiles.Where(file => selectedItems.Contains(file.uuid)).ToList())
		{
			file.dateTakenSource = ImportFile.DateTakenSource.Custom;
			file.customDateTaken = null;
		}
	}

	///Updates the collections field of each selected ImportItem.
	private static void UpdateCollections()
	{
		foreach (ImportFile file in importFiles.Where(file => selectedItems.Contains(file.uuid)))
		{
			file.collections ??= new HashSet<C.Collection>();

			if (CS.checkedFolderIndex != -1)
			{
				file.collections.Clear();
				file.collections.Add(CS.folders[CS.checkedFolderIndex]);
			}
			else
			{
				file.collections.RemoveWhere(folder => CS.folders.Contains(folder)); //TODO: there's probably a better/more efficient way to do this.
				
				for (int a = 0; a < CS.checkedAlbums.Count; a++)
				{
					if (CS.checkedAlbums[a] == false) continue;
					file.collections.Add(CS.albums[a]);
				}
			}
		}
	}

	private static async void FocusSearchInput() => await searchInput.FocusAsync();
}